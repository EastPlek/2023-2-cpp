

=============================================
 Upload Time : 12/04/23 Monday 17:31:31
=============================================

//-----------------------------------------------------------------------------
// 2023학년 2학기 c++ 12월 4일 | 월 | 9 ~ 10 수 |  7 ~ 8		      (14주 1일)
// 
// 2023. 12. 11 월요일 (15주 1) - 한 학기 정리, 책소개 , 종강
// 2023. 12. 13 수요일 (15주 2) - 기말 시험, 12월 18일 월요일 - 성적 게시
// 
//-----------------------------------------------------------------------------
// C++ 템플릿
//-----------------------------------------------------------------------------
// 과제 - 나만의 자료형을 많이 만들어 볼 것.
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// 왜 필요한가?
// 뭐가 좋은가?
// 진짜 좋은 것은 무엇인가?

// [문제] main을 수정하지 않고 의도대로 실행되도록 해 주세요.

void change(int&, int&);

int main(void)
{
	int a{ 1 }, b{ 2 };
	change(a, b);

	std::cout << a << "," << b << '\n'; // 2, 1
	save("32.cpp", "FileOutput\\2023_12_04 CPP 32-output", std::ios::app, true);
}

void change(int& a, int& b) {
	int tmp{ a };
	a = b;
	b = tmp;
}

=============================================
 Upload Time : 12/04/23 Monday 18:29:13
=============================================

//-----------------------------------------------------------------------------
// 2023학년 2학기 c++ 12월 4일 | 월 | 9 ~ 10 수 |  7 ~ 8		      (14주 1일)
// 
// 2023. 12. 11 월요일 (15주 1) - 한 학기 정리, 책소개 , 종강
// 2023. 12. 13 수요일 (15주 2) - 기말 시험, 12월 18일 월요일 - 성적 게시
// 
//-----------------------------------------------------------------------------
// C++ 템플릿
//-----------------------------------------------------------------------------
// 과제 - 나만의 자료형을 많이 만들어 볼 것.
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// 왜 필요한가? - C++ 언어는 함수의 오버로딩이 가능하다. (전달인자의 타입이 다르다면)
//                같은 기능의 함수를 자료형만 바꿔 계속 만들어야한다. -> 컴퓨터가 대신 하도록
//                -> 템플릿 (소스코드를 컴파일러가 생성할 수 있는 틀)
//				  
// 뭐가 좋은가?
// 진짜 좋은 것은 무엇인가?

// [문제] main을 수정하지 않고 의도대로 실행되도록 해 주세요.


class Dog {
	int age{};
public:
	Dog(int i) : age{ i } {}

	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.age;
	}
};

// 소스코드를 찍어낼 수 있도록 프로그래머가 틀을 제공해야한다.
// 템플릿 소스코드는 자료형에 맞는 소스코드를 찍어내기 때문에 
// 소스코드를 감출 수 없다.
// 템플릿은 반드시 선언과 정의를 동시에 한다.
template <class T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
}

#include <stdio.h>
int main(void)
{
	std::cout << "몇글자 - " << printf("abc") << '\n';
	{
		int a{ 1 }, b{ 2 };
		change(a, b); // 1. change(int, int)
		              // 2. change(int&, int&)
		              // 3. change<int>( int, int )
		std::cout << a << ", " << b << '\n';
	}
	{
		std::string a{ "2023" }, b{ "1204" };
		change(a, b);

		std::cout << a << ", " << b << '\n';
 	}
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);

		std::cout << a << "," << b << '\n'; // 2, 1
	}
	save("32.cpp", "FileOutput\\2023_12_04 CPP 32-output", std::ios::app, true);
}

=============================================
 Upload Time : 12/04/23 Monday 18:59:12
=============================================

//-----------------------------------------------------------------------------
// 2023학년 2학기 c++ 12월 4일 | 월 | 9 ~ 10 수 |  7 ~ 8		      (14주 1일)
// 
// 2023. 12. 11 월요일 (15주 1) - 한 학기 정리, 책소개 , 종강
// 2023. 12. 13 수요일 (15주 2) - 기말 시험, 12월 18일 월요일 - 성적 게시
// 
//-----------------------------------------------------------------------------
// C++ 템플릿
//-----------------------------------------------------------------------------
// 과제 - 나만의 자료형을 많이 만들어 볼 것.
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std::string_literals;

// 왜 필요한가? - C++ 언어는 함수의 오버로딩이 가능하다. (전달인자의 타입이 다르다면)
//                같은 기능의 함수를 자료형만 바꿔 계속 만들어야한다. -> 컴퓨터가 대신 하도록
//                -> 템플릿 (소스코드를 컴파일러가 생성할 수 있는 틀)
//				  
// 뭐가 좋은가?
//      소스코드를 생성해준다.
//      
// 진짜 좋은 것은 무엇인가?

// [문제] main을 수정하지 않고 의도대로 실행되도록 해 주세요.


class Dog {
	int age{};
public:
	Dog(int i) : age{ i } {}

	Dog operator+(const Dog& rhs) const {
		return Dog{ age + rhs.age };
	}

	friend std::ostream& operator<< (std::ostream& os, const Dog& dog) {
		return os << dog.age;
	}
};

// 소스코드를 찍어낼 수 있도록 프로그래머가 틀을 제공해야한다.
// 템플릿 소스코드는 자료형에 맞는 소스코드를 찍어내기 때문에 
// 소스코드를 감출 수 없다.
// 템플릿은 반드시 선언과 정의를 동시에 한다.


template <class T>
T add(T a, T b)
{return a + b;}

const char* add(const char* a, const char* b) // 템플릿 특수화(specialization)
{
	char* temp = new char[strlen(a) + strlen(b) + 1];
	memcpy(temp, a, strlen(a));
	memcpy(temp+strlen(a), b, strlen(b));
	temp[strlen(a) + strlen(b)] = '\0';

	return temp;
}


#include <stdio.h>
int main(void)
{
	std::cout << add(1, 2) << '\n'; // 3
	std::cout << add("2023","1204") << '\n'; // 20231204 포인터끼리의 덧셈은 사도
	std::cout << add(Dog{ 1 }, Dog{ 2 }) << '\n'; // 3
	save("32.cpp", "FileOutput\\2023_12_04 CPP 32-output", std::ios::app, true);
}